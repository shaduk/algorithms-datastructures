{"changed":false,"filter":false,"title":"job_queue.cpp","tooltip":"/Problems/job_queue.cpp","value":"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing std::vector;\nusing std::cin;\nusing std::cout;\n\nclass JobQueue {\n private:\n  int num_workers_;\n  vector<int> jobs_;\n\n  vector<int> assigned_workers_;\n  vector<long long> start_times_;\n\n  void WriteResponse() const {\n    for (int i = 0; i < jobs_.size(); ++i) {\n      cout << assigned_workers_[i] << \" \" << start_times_[i] << \"\\n\";\n    }\n  }\n\n  void ReadData() {\n    int m;\n    cin >> num_workers_ >> m;\n    jobs_.resize(m);\n    for(int i = 0; i < m; ++i)\n      cin >> jobs_[i];\n  }\n\n  void AssignJobs() {\n    // TODO: replace this code with a faster algorithm.\n    assigned_workers_.resize(jobs_.size());\n    start_times_.resize(jobs_.size());\n    vector<long long> next_free_time(num_workers_, 0);\n    for (int i = 0; i < jobs_.size(); ++i) {\n      int duration = jobs_[i];\n      int next_worker = 0;\n      for (int j = 0; j < num_workers_; ++j) {\n        if (next_free_time[j] < next_free_time[next_worker])\n          next_worker = j;\n      }\n      assigned_workers_[i] = next_worker;\n      start_times_[i] = next_free_time[next_worker];\n      next_free_time[next_worker] += duration;\n    }\n  }\n\n public:\n  void Solve() {\n    ReadData();\n    AssignJobs();\n    WriteResponse();\n  }\n};\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  JobQueue job_queue;\n  job_queue.Solve();\n  return 0;\n}\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":180,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":9,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1476926201609}